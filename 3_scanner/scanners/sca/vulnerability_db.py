# scanners/sca/vulnerability_db.py
import json
import os
from copy import deepcopy

PQC_VULNERABLE_LIBRARIES = {
    "python": {
        "pycrypto": {
            "all_versions_vulnerable": True,
            "reason": "RSA/DSA library without PQC support.",
            "pqc_support": False,
            "pqc_classification": "Traditional Crypto Library",
            "alternatives": [
                {"name": "pqcrypto", "version": ">=0.2.0"},
                {"name": "liboqs-python", "version": ">=0.7.0"},
            ],
        },
        "cryptography": {
            "all_versions_vulnerable": False,
            "vulnerable_versions": ["<41.0.0"],
            "reason": "Versions below 41.0.0 lack PQC support.",
            "pqc_support": "partial",
            "pqc_classification": "Traditional Crypto Library",
            "pqc_version": ">=41.0.0",
            "alternatives": [],
        },
        "m2crypto": {
            "all_versions_vulnerable": True,
            "reason": "OpenSSL-based library without PQC support.",
            "pqc_support": False,
            "pqc_classification": "Traditional Crypto Library",
            "alternatives": [
                {"name": "pqcrypto", "version": ">=0.2.0"},
            ],
        },
        "rsa": {
            "all_versions_vulnerable": True,
            "reason": "RSA-only library without PQC support.",
            "pqc_support": False,
            "pqc_classification": "Traditional Crypto Library",
            "alternatives": [
                {"name": "pqcrypto", "version": ">=0.2.0"},
            ],
        },
        "ecdsa": {
            "all_versions_vulnerable": True,
            "reason": "ECDSA-only library without PQC support.",
            "pqc_support": False,
            "pqc_classification": "Traditional Crypto Library",
            "alternatives": [
                {"name": "pqcrypto", "version": ">=0.2.0"},
            ],
        },
        "pyopenssl": {
            "all_versions_vulnerable": True,
            "reason": "OpenSSL-based TLS library without PQC support.",
            "pqc_support": False,
            "pqc_classification": "Traditional Crypto Library",
            "alternatives": [],
        },
        "pycryptodome": {
            "all_versions_vulnerable": True,
            "reason": "Traditional crypto primitives without PQC support.",
            "pqc_support": False,
            "pqc_classification": "Traditional Crypto Library",
            "alternatives": [],
        },
    },
    "javascript": {
        "node-rsa": {
            "all_versions_vulnerable": True,
            "reason": "RSA-only library without PQC support.",
            "pqc_support": False,
            "pqc_classification": "Traditional Crypto Library",
            "alternatives": [
                {"name": "@stablelib/kyber", "version": "latest"},
            ],
        },
        "jsrsasign": {
            "all_versions_vulnerable": True,
            "reason": "RSA signature library without PQC support.",
            "pqc_support": False,
            "pqc_classification": "Traditional Crypto Library",
            "alternatives": [],
        },
        "crypto-js": {
            "all_versions_vulnerable": True,
            "reason": "Symmetric crypto library without PQC support.",
            "pqc_support": "none",
            "pqc_classification": "Traditional Crypto Library",
            "alternatives": [],
        },
        "elliptic": {
            "all_versions_vulnerable": True,
            "reason": "ECC library without PQC support.",
            "pqc_support": False,
            "pqc_classification": "Traditional Crypto Library",
            "alternatives": [],
        },
        "node-forge": {
            "all_versions_vulnerable": True,
            "reason": "Traditional crypto primitives without PQC support.",
            "pqc_support": False,
            "pqc_classification": "Traditional Crypto Library",
            "alternatives": [],
        },
    },
    "java": {
        "bouncycastle": {
            "all_versions_vulnerable": False,
            "vulnerable_versions": ["<1.70"],
            "reason": "Versions below 1.70 lack PQC support.",
            "pqc_support": "partial",
            "pqc_classification": "Traditional Crypto Library",
            "pqc_version": ">=1.70",
            "alternatives": [],
        },
        "bcprov-jdk15on": {
            "all_versions_vulnerable": False,
            "vulnerable_versions": ["<1.70"],
            "reason": "Legacy Bouncy Castle provider without PQC support.",
            "pqc_support": "partial",
            "pqc_classification": "Traditional Crypto Library",
            "pqc_version": ">=1.70",
            "alternatives": [],
        },
    },
}


def _deep_merge(base: dict, extra: dict) -> dict:
    for key, value in extra.items():
        if key in base and isinstance(base[key], dict) and isinstance(value, dict):
            _deep_merge(base[key], value)
        else:
            base[key] = value
    return base


def load_pqc_db() -> dict:
    db = deepcopy(PQC_VULNERABLE_LIBRARIES)
    db_path = os.getenv("SCA_PQC_DB_PATH")
    default_path = os.path.join(os.path.dirname(__file__), "pqc_vuln_db.json")
    if not db_path and os.path.exists(default_path):
        db_path = default_path
    if db_path and os.path.exists(db_path):
        try:
            with open(db_path, "r", encoding="utf-8") as f:
                extra = json.load(f)
            if isinstance(extra, dict):
                _deep_merge(db, extra)
        except Exception:
            pass
    return db
